% Near-field MA sensing with range-dependent amplitude
% Discrete sampling + sequential update (Algorithm 1 style) for a fixed (u,r)
% Objective: minimize Tr(CRB) = Tr( (Sigma_G + Sigma_H)^{-1} ) at given (u,r)
clc; clear; close all;
fprintf('Running sampling_algorithm_all_ur_non_uwm (script)...\n');

%% ------------------------- Problem parameters ---------------------------
lambda = 1;                 % normalized wavelength
N      = 16;                % number of antennas
d      = 0.15*lambda;       % minimum spacing
a      = 5*lambda;          % half-aperture; domain is [-a, a]
A      = 2*a;               % full length
M      = 4000;              % number of discrete candidate positions
S      = linspace(-a, +a, M);   % candidate positions on [-a, a]
% Near-field distance bounds (typical textbook formulas; replace with your paper's exact range if needed)
R_FS  = 0.62*sqrt(A^3/lambda);   % Fresnel (near-field) lower bound
R_RL  = 2*A^2/lambda;            % Rayleigh distance (far-field) boundary
r_min = R_FS;
r_max = R_RL/2;


% Fixed target parameters (u = cos(theta), r > 0)
u = 0.99;                   % |u| < 1
r = 50;                     % range (units consistent with lambda)
if abs(u) >= 1, error('u must satisfy |u| < 1.'); end
if (N-1)*d > 2*a + 1e-12
    error('(N-1)*d must be <= 2a to fit N=%d with spacing d=%g.', N, d);
end

% Optional parallel pool (not necessary since we use 'for' below)
% pool = gcp('nocreate'); if isempty(pool), try, parpool('threads'); catch, try parpool; catch, end, end

%% --------------------- Initialization (two-group ends) ------------------
apv_init = two_group_init_sym(N, d, a);   % ends-loaded pattern on [-a, a]
apv_star = apv_init;                      % working solution
apv_fixR = apv_init;                      % anchors for not-yet-updated elements

%% ------------------- Sequential update over elements --------------------
num_outer_pass = 20;   % more passes reduce greediness
for pass = 1:num_outer_pass
    for n = 1:N
        % Build feasible set S_n respecting min spacing to both updated left and anchored right
        S_mask = true(size(S));
        for i = 1:n-1
            S_mask = S_mask & (abs(S - apv_star(i)) >= d - 1e-9);
        end
        for j = n+1:N
            S_mask = S_mask & (abs(S - apv_fixR(j)) >= d - 1e-9);
        end
        S_n = S(S_mask);
        if isempty(S_n)
            error('Feasible set empty at n=%d (pass %d). Increase M or relax constraints.', n, pass);
        end

        % Evaluate objective at each candidate position for antenna n (fixed u, r)
        scores = -inf(1, numel(S_n));
        left_fixed  = apv_star(1:n-1);
        right_fixed = apv_fixR(n+1:N);
        u_local = u; r_local = r;

        for k = 1:numel(S_n)
            s = S_n(k);
            x_hat = sort([left_fixed, s, right_fixed]);  % candidate APV
            % reject if any spacing violated (numerical tolerance)
            if any(diff(x_hat) < d - 1e-9)
                scores(k) = -inf; 
                continue;
            end
            % Tr(CRB) at fixed (u,r): minimize => maximize negative
            scores(k) = -objective_trace_crb_fixed(x_hat, u_local, r_local, lambda);
        end

        % Commit best candidate for antenna n
        [~, idx] = max(scores);
        apv_star(n) = S_n(idx);
    end
    % Re-anchor right side to current solution to avoid stale constraints next pass
    apv_fixR = apv_star;
end

apv_opt = sort(apv_star);

%% ------------------------------ Plot ------------------------------------
figure('Color','w'); hold on; box on;
y0 = zeros(size(apv_opt));
groups = split_into_groups(apv_opt, d, 1e-3*d);
colors = lines(max(groups));
for g = 1:max(groups)
    idx = find(groups == g);
    scatter(apv_opt(idx), y0(idx), 70, colors(g,:), 'filled', 'MarkerEdgeColor','k');
end
plot([-a a],[0 0],'k-','LineWidth',1.5);
xline(-a,'k:','LineWidth',1); xline(a,'k:','LineWidth',1); xline(0,'k--');
xlabel('Position x (on [-a,a])'); yticks([]); ylim([-0.3 0.3]); xlim([-a a]);
title(sprintf('Optimized APV for fixed u=%.3f, r=%.3f (range-dependent amplitude)', u, r));
legend(arrayfun(@(g) sprintf('Group %d',g), 1:max(groups), 'UniformOutput',false), ...
       'Location','northoutside','Orientation','horizontal');
fprintf('Optimized APV (positions, in units of lambda):\n'); disp(apv_opt.');
drawnow;

%% ---------------------------- Helpers -----------------------------------
function x0 = two_group_init_sym(N, d, a)
% Symmetric two-group ends-loaded pattern on [-a, a] with spacing d
K = floor(N/2);
left  = -a + (0:(K-1))*d;
right = +a - (0:(N-K-1))*d;
x0 = sort([left, right]);
end

function J = objective_trace_crb_fixed(x, u, r, lambda)
% Objective at fixed (u,r): Tr(CRB) ∝ Tr( (Sigma_G + Sigma_H)^{-1} )
Sig = sigma_blocks(x, u, r, lambda);    % Sigma_G + Sigma_H from amplitude-weighted covariances
% Guard against degeneracy
if any(isnan(Sig(:))) || any(~isfinite(Sig(:)))
    J = inf; return;
end
% Positive definiteness check
[~,p] = chol(Sig);
if p ~= 0
    J = inf; return;
end
R = inv(Sig);
J = trace(R);
end

function Sig = sigma_blocks(x, u, r, lambda)
% Build Sigma_G(w) + Sigma_H(w) from amplitude-weighted covariances
% Exact path length r_m(x) and exact amplitude B_m used
% Fresnel-phase gradients for G_u, G_r; log-amplitude gradients H_u, H_r exact

% Geometry and exact amplitude
x = x(:).';
kappa = 2*pi/lambda;                          % kappa = 2π/λ
rm = sqrt(r^2 - 2*r*u*x + x.^2);   % exact path length to each sensor
Bm = 1 ./ sqrt(4*pi*rm.^2);            % exact amplitude (up to constant 4π)

% Normalized weights w_m ∝ B_m^2
B2 = Bm.^2;
S0 = sum(B2);
w  = B2 / max(S0, eps);

% Fresnel-phase approximation (near-field quadratic phase):
% phi(x) ≈ K ( u x + (1 - u^2) x^2 / (2 r) )
% => gradients:
Gu = kappa * ( x + (u * x.^2) / r );           
Gr = kappa * ( (1 - u^2) * x.^2 ) / (2*r^2 ); 

% Log-amplitude gradients from exact amplitude model:

Hr    = -(r - u*x) ./ rm^2;       % H_r = -2(r - u x)/r_m^2
Hu    = r*x ./ rm^2;       % H_u =  2 x / r_m^2

% Weighted means
mw = @(f) sum(w .* f);
Gw_u_bar = mw(Gu); Gw_r_bar = mw(Gr);
Hw_u_bar = mw(Hu); Hw_r_bar = mw(Hr);

% Mean-removed
Gu0 = Gu - Gw_u_bar; Gr0 = Gr - Gw_r_bar;
Hu0 = Hu - Hw_u_bar; Hr0 = Hr - Hw_r_bar;

% Weighted variances and covariances
varw  = @(f0) sum(w .* (f0.^2));
covw  = @(f0,g0) sum(w .* (f0 .* g0));

Var_Gr   = varw(Gr0);
Var_Gu   = varw(Gu0);
Cov_GuGr = covw(Gu0, Gr0);

Var_Hu   = varw(Hu0);
Var_Hr   = varw(Hr0);
Cov_HuHr = covw(Hu0, Hr0);

% Sigma blocks (2x2), summed per attachment:
% Σ_G(w) = [ Var(Gr)   Cov(Gu,Gr);
%            Cov(Gu,Gr)  Var(Gu) ]
% Σ_H(w) = [ Var(Hu)   Cov(Hr,Hu);
%            Cov(Hu,Hr) Var(Hr) ]
Sigma_G = [Var_Gr,      Cov_GuGr;
           Cov_GuGr,    Var_Gu];

Sigma_H = [Var_Hu,      Cov_HuHr;
           Cov_HuHr,    Var_Hr];

Sig = Sigma_G + Sigma_H;  % projected FIM (up to constants), CRB ∝ inv(Sig)
end

function grp = split_into_groups(x, d, tol)
% Group indices based on adjacency with gap ~ d (for visualization)
x = sort(x(:).');
grp = zeros(size(x));
g = 1; grp(1) = g;
for i = 2:numel(x)
    if abs((x(i) - x(i-1)) - d) <= max(tol, 1e-12)
        grp(i) = g;
    else
        g = g + 1;
        grp(i) = g;
    end
end
end
