function compare_snr_curve()
clc; clear;

%% ===== Fixed parameters =====
lambda = 8e-3;
k      = 2*pi/lambda;
r      = 10;
u      = 0.6;
a      = 10*lambda;
Es     = 1;

% SNR sweep (dB)
SNRdB = linspace(-10, 30, 41);
SNR   = 10.^(SNRdB/10);
sigma2_list = Es ./ SNR;  % sigma^2 = Es / SNR

%% ===== Kernel and helper (Eq. (22) kernel; Eq. (16)-(20) for CRB) =====
r_of_x   = @(x) sqrt(r^2 - 2*r*u*x + x.^2);
phi_core = @(x) (k^2 + 1./(r_of_x(x).^2)) ./ (r_of_x(x).^4);  % Eq. (22)

CRB_from_support = @(xs, ps, sigma2) ...
    metric_from_support(xs, ps, phi_core, r_of_x, r, u, Es, sigma2);

%% ===== Case 1: symmetric optimal weights (Theorem 1) =====
x_minus = -a; x_zero = 0; x_plus = +a;
phi_m = phi_core(x_minus);
phi_0 = phi_core(x_zero);
phi_p = phi_core(x_plus);

A     = 2 - phi_0*(1/phi_m + 1/phi_p);
tmax  = 1/(1/phi_m + 1/phi_p);
C1    = 1 + (u^2)/(r^2);

if A >= 0
    p0 = 0;
    p_minus = phi_p/(phi_m + phi_p);
    p_plus  = phi_m/(phi_m + phi_p);
else
    B = -A;
    t_star = phi_0 / (B + sqrt(2*a^2*C1*B));
    t_star = min(t_star, tmax);
    p_minus = t_star/phi_m;
    p_plus  = t_star/phi_p;
    p0      = 1 - t_star*(1/phi_m + 1/phi_p);
end
xs1 = [x_minus, x_zero, x_plus];
ps1 = [p_minus, p0,     p_plus];

%% ===== Case 2: right-edge cluster =====
delta = 1e-3 * a;
xs2   = [a-delta, a];
ps2   = [0.5, 0.5];

%% ===== Compute Tr(J^-1) vs SNR =====
TrJinv1 = zeros(size(SNR));
TrJinv2 = zeros(size(SNR));

for i = 1:length(SNR)
    sigma2 = sigma2_list(i);
    [~,~,TrJinv1(i)] = CRB_from_support(xs1, ps1, sigma2);
    [~,~,TrJinv2(i)] = CRB_from_support(xs2, ps2, sigma2);
end

%% ===== Plot =====
figure;
semilogy(SNRdB, TrJinv1, 'b-o', 'LineWidth',1.5); hold on;
semilogy(SNRdB, TrJinv2, 'r--s', 'LineWidth',1.5);
grid on;
xlabel('SNR (dB)','FontSize',12);
ylabel('Tr(J^{-1}) (CRB metric)','FontSize',12);
legend({'Optimal symmetric 3-point','Clustered near +a'},'Location','southwest');
title(sprintf('CRB metric vs SNR  (r=%.1fm, u=%.2f, a=%.1f\\lambda)',r,u,a/lambda));
set(gca,'FontSize',12);
end


%% ===== Subfunction (uses Eq. (16)-(20)) =====
function [CRBu, CRBr, TrJinv] = metric_from_support(xs, ps, phi_core, r_of_x, r, u, Es, sigma2)
% --- Weights: w_m = (Es/(2*pi*sigma^2)) * phi_core(x_m)  (Eq. (14))
c    = Es/(2*pi*sigma2);
wm   = ps(:) .* (c * phi_core(xs(:)));

S0   = sum(wm);
xbar = sum(xs(:).*wm)/S0;
x2   = sum((xs(:).^2).*wm)/S0;

% --- Compact FIM (Eq. (16))
Juu  = r^2 * S0 * x2;
Jrr  = S0 * (r^2 - 2*r*u*xbar + (u^2)*x2);
Jur  = - r * S0 * (r*xbar - u*x2);

% --- detJ (Eq. (18)) with small numerical guard
detJ = Juu*Jrr - Jur^2;
detJ = max(detJ, 1e-18);

% --- Closed-form CRBs (Eq. (19)-(20)); no extra 2*Es/sigma^2 factor here
CRBu  = Jrr / detJ;
CRBr  = Juu / detJ;
TrJinv = CRBu + CRBr;
end
