% example parameters
lambda = 8e-3;         % 8 mm
a      = 10*lambda;    % half-aperture
theta  = acos(0.6);    % pick u=0.6, so theta=acos(0.6)
r      = 10;           % 10 m

% mode = 'PA' (g=a) or 'MIMO' (g=a⊗a); grid step 0.005 is usually fine
[p1_opt, p0_opt, Tr_min] = search_p1_p0_minTrCRB(theta, r, lambda, a, ...
                                'PA', 0.005, 1e-5, 1e-4);



function [p1_star, p0_star, TrCRB_min] = search_p1_p0_minTrCRB(theta, r, lambda, a, ...
    mode, gridStep, epsTheta, epsR)
%SEARCH_P1_P0_MINTRCRB
%  Numerically searches (p1, p0) on a 2D grid to minimize Tr(CRB)
%  under the page-1 unified CRB formulas (Eqs. (20)–(22) in the paper).
%
%  INPUTS
%    theta   : AoA parameter (rad) used in g(r,theta)
%    r       : range (m)
%    lambda  : wavelength (m)
%    a       : half-aperture for the 3-point support at {-a, 0, +a}
%    mode    : 'MIMO' (g = a ⊗ a) or 'PA' (phased-array, g = a)
%              -- this is just a convenient example builder for g(r,theta);
%              you can replace g_builder() with your own black-box.
%    gridStep: step for p1 and p0 (e.g. 0.005)
%    epsTheta: finite-difference step for theta (e.g. 1e-5)
%    epsR    : finite-difference step for r (e.g. 1e-4)
%
%  OUTPUTS
%    p1_star    : optimal left weight (at x=-a)
%    p0_star    : optimal center weight (at x=0)
%    TrCRB_min  : minimal Tr(CRB) found on the grid

if nargin < 6 || isempty(gridStep), gridStep = 0.005; end
if nargin < 7 || isempty(epsTheta), epsTheta = 1e-5;  end
if nargin < 8 || isempty(epsR),     epsR     = 1e-4;  end

% --- 3 support locations: left, center, right
xs = [-a, 0, +a];

% --- initialize best record
TrCRB_min = inf; p1_star = NaN; p0_star = NaN;

% --- predefine a small helper to compute Tr(CRB) from g,gθ,gr via Eqs. (20)–(22)
    function TrCRB = trCRB_from_g(g, gth, gr)
        % norms
        ng   = norm(g);
        ngth = norm(gth);
        ngr  = norm(gr);

        % sin^2Ω and sin^2Θ (Eq. (20))
        sin2Omega = 1 - (abs(gth'*g)^2)/(ngth^2 * ng^2 + eps);
        sin2Theta = 1 - (abs(gr' *g)^2)/(ngr^2  * ng^2 + eps);

        % W = (gθ^H gr) I - gθ gr^H  (Eq. (20))
        Ghg = (gth' * gr);
        Wg  = Ghg * g - gth * (gr' * g);
        Rgg = real(g' * Wg);

        % Q' entries (Eq. (20))
        Q11 = ngth^2 * sin2Omega;
        Q22 = ngr^2  * sin2Theta;
        Q12 = Rgg / (ng^2 + eps);

        detQp = Q11*Q22 - Q12^2;         % det Q'
        % Up to a common positive scale (N0 / (2|ρ|^2)) which
        % does not affect argmin over (p1,p0):
        CRB_theta = Q22 / (detQp + eps);
        CRB_r     = Q11 / (detQp + eps);
        TrCRB     = CRB_theta + CRB_r;   % A-optimal metric
    end

% --- builder for g(r,theta) given weights p = [p1,p0,p2]
% NOTE: This is just a convenient example consistent with page-1 usage:
%       we construct an array response a(r,theta) with spherical phases and 1/r amplitude,
%       then set g = a (phased-array, 'PA') or g = kron(a, a) ('MIMO').
    function g = g_builder(theta_, r_, p)
        % per-element distance to target (exact spherical distance)
        rm = sqrt(r_^2 - 2*r_*cos(theta_)*xs + xs.^2);   % r(x) with u = cos(theta)
        % simple near-field response per element (amplitude ~ 1/rm, phase exp(-j2π rm/λ))
        a_vec = (1./rm) .* exp(-1j*2*pi*rm/lambda);

        % apply weights on the 3 “atoms” at {-a,0,+a}
        a_w = sqrt(p(:)).' .* a_vec;     % sqrt-p scaling is optional; you can also use p(:).'

        switch upper(mode)
            case 'MIMO'
                g = kron(a_w, a_w).';    % column vector
            otherwise  % 'PA'
                g = a_w.';               % column vector
        end
    end

% --- grid over p1 in [0,1], p0 in [0,1-p1]; p2 = 1 - p1 - p0
pVals = 0:gridStep:1;
for p1 = pVals
    p0_max = 1 - p1;
    p0Vals = 0:gridStep:p0_max;

    for p0 = p0Vals
        p2 = 1 - p1 - p0;
        if p2 < 0, continue; end

        p = [p1, p0, p2];

        % central finite-difference for gθ and gr (page-1 only needs g,gθ,gr)
        g    = g_builder(theta, r, p);
        g_th = (g_builder(theta+epsTheta, r, p) - g_builder(theta-epsTheta, r, p))/(2*epsTheta);
        g_r  = (g_builder(theta, r+epsR, p)     - g_builder(theta, r-epsR, p)    )/(2*epsR);

        TrC = trCRB_from_g(g, g_th, g_r);

        if isfinite(TrC) && TrC < TrCRB_min
            TrCRB_min = TrC;
            p1_star   = p1;
            p0_star   = p0;
        end
    end
end

fprintf('Best (p1,p0,p2) = (%.4f, %.4f, %.4f);  min Tr(CRB) = %.6e\n', ...
        p1_star, p0_star, 1-p1_star-p0_star, TrCRB_min);
end
